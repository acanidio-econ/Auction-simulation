The scripts generate simulated bids to evaluate different metrics under different auction formats. To generate these bids, the script assumes that there are s bidders and n items being auctioned off, where an item can be interpreted as an order on a specific directed token pair, with each item being a different directed token pair.  It then assumes that each bidder draws a random valuation for each item, which is how much the bidder would bid only on that item. These valuations can be negative, meaning that a solver may not know how to execute an order.

Then the code calculates each bidder's valuations for all subsets of 2 items (i.e., for each possible batched bid of size 2) in the following way: there is a probability .9 that there are no additional efficiencies from bundling the two items together, so the bidder doesn't want to bid on a bundle. There is, however, a .1 probability that these additional efficiencies exist, and in this case, the value of each item in the bundle increases by a random percentage between 0% and 5%.

To generate the valuations for *all* possible subsets of 3 or more items, the scripts proceed by iteration. Suppose that, for a given bidder, you have determined the value of all items when in subsets up to k elements and want to determine the values of the same items when in subsets of k+1 elements. The script considers all subsets of n having k+1 elements, then computes the most valuable partition of each subset using only subsets of k elements or fewer (from the same bidder). Then, with 10% probability, it increases the value of the items in this k+1 subset by a random percentage between 0 and 5% relative to the value of these items in its most valuable partition with only subsets of k elements or fewer. The script continues until k=n.

After generating the bids, the scripts then compute the outcome of a repeated batch auction (repeat until all orders are executed), of a "simple combinatorial auction" (ths simple algorithm discussed earlier: first looks at the bid with the most significant score, then looks for a second winner among bids that have nothing in common with the winning bid, ..), a "simple combinatorial auction with filtering" which is the same but with the fairness filter, of a combinatorial auction (with a timeout) and of a fair combnatorial auction. It repeats everything 500 times and reports the average score and rewards for each type of auction. For the repeated batch auction, it also reports the number of auctions it took to execute all orders. The script assumes that solvers' rewards are capped below by zero and are uncapped above, and it counts the number of times the cap is biding (i.e., rewards would be negative without it). 

